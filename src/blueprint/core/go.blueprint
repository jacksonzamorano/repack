[meta id]go[/meta]
[meta name]Go[/meta]

[define int32]int32[/define]
[define int64]int64[/define]
[define float64]float64[/define]
[define string]string[/define]
[define uuid]uuid.UUID[/define]
[define boolean]bool[/define]
[define datetime]time.Time[/define]
[link uuid]import "github.com/google/uuid"[/link]
[link datetime]import "time"[/link]
[link sql]import "database/sql"[/link]

[file]model.go[/file]
package [package];

[imports]

[each enum][br]
type [name] string

const (
	[each case][br]
	[enum_name][name] [enum_name] = "[value]"
	[/each][br]
)
[/each][br]

[each struct][br]
type [name] struct {
	[each field][br]
	[name.titlecase] [if optional][nfunc go.nopointer]*[/nfunc][/if][if array]\[][/if][type] `json:"[name][func go.omitempty],omitempty[/func]"`
	[/each][br]
}

[if queries][br]
func Scan[name](val *[name], row *sql.Rows) error {
	if err := row.Scan([each field][nfunc orm.noread]&val.[name.titlecase][if sep], [/if][/nfunc][/each]); err != nil {
		return err
	}
	return nil
}[br]
[/if]

[each query][br]
[import sql]
func [name](db *sql.DB, [each arg][name] [type], [/each][trim], [/trim])
[if returns_many]
 (\[][struct_name], error) 
[/if][if returns_one]
 (*[struct_name], error) 
[/if][if returns_none]
 error 
[/if]
{[br]
	[if returns_many]
	values := make(\[][struct_name], 0)[br]
	[/if]
	rows, err := db.Query("[query]", [each arg][name], [/each][trim], [/trim])
	if err != nil {[br]
		[if returns_none]
		return err
		[/if][if returns_one]
		return nil, err
		[/if][if returns_many]
		return values, err
		[/if]
		[br]
	}
	defer rows.Close()[br]
	[if returns_none]
	return nil
	[/if]
	[if returns_many]
	for rows.Next() {
		var value [struct_name][br]
		if err := Scan[struct_name](&value, rows); err != nil {
			return values, err
		}
		values = append(values, value)
	}
	return values, nil
	[/if]
	[if returns_one]
	var value [struct_name];
	if !rows.Next() {
		return nil, nil
	}
	return &value, Scan[struct_name](&value, rows)
	[/if][br]
}
[/each]
